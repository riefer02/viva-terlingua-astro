import fs from 'fs';
import path from 'path';
import { config as dotenvConfig } from 'dotenv';

// Load environment variables from .env file
dotenvConfig();

interface OpenAPISchema {
  paths: Record<string, any>;
  components: {
    schemas: Record<string, any>;
  };
}

// Utility types
type Nullable<T> = T | null;

interface StrapiBaseAttributes {
  id: number;
  documentId: string;
  createdAt?: string;
  updatedAt?: string;
  publishedAt?: string;
  locale?: string;
}

interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

interface StrapiMedia {
  data: {
    id: number;
    attributes: {
      name: string;
      alternativeText: string | null;
      caption: string | null;
      width: number;
      height: number;
      formats: {
        thumbnail?: {
          url: string;
          width: number;
          height: number;
        };
        small?: {
          url: string;
          width: number;
          height: number;
        };
        medium?: {
          url: string;
          width: number;
          height: number;
        };
        large?: {
          url: string;
          width: number;
          height: number;
        };
      };
      hash: string;
      ext: string;
      mime: string;
      size: number;
      url: string;
      previewUrl: string | null;
      provider: string;
      createdAt: string;
      updatedAt: string;
    };
  } | null;
}

async function generateTypes() {
  const STRAPI_URL = process.env.STRAPI_URL || 'http://127.0.0.1:1337';
  const STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;

  if (!STRAPI_API_TOKEN) {
    throw new Error('STRAPI_API_TOKEN is required but not found in .env file');
  }

  try {
    // Fetch OpenAPI documentation from Strapi
    const response = await fetch(`${STRAPI_URL}/api/docs/full`, {
      headers: {
        Authorization: `Bearer ${STRAPI_API_TOKEN}`,
      },
    });

    if (!response.ok) {
      throw new Error(
        `Failed to fetch API documentation: ${response.statusText}`
      );
    }

    const data: OpenAPISchema = await response.json();
    const schemas = data.components.schemas;

    // Generate TypeScript interfaces
    let typeDefinitions = `// Generated Types from Strapi API Documentation
// DO NOT EDIT THIS FILE MANUALLY

// Base Types
export type Nullable<T> = T | null;

export interface StrapiBaseAttributes {
  id: number;
  documentId: string;
  createdAt?: string;
  updatedAt?: string;
  publishedAt?: string;
  locale?: string;
}

export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

export interface StrapiMedia {
  data: {
    id: number;
    attributes: {
      name: string;
      alternativeText: string | null;
      caption: string | null;
      width: number;
      height: number;
      formats: {
        thumbnail?: {
          url: string;
          width: number;
          height: number;
        };
        small?: {
          url: string;
          width: number;
          height: number;
        };
        medium?: {
          url: string;
          width: number;
          height: number;
        };
        large?: {
          url: string;
          width: number;
          height: number;
        };
      };
      hash: string;
      ext: string;
      mime: string;
      size: number;
      url: string;
      previewUrl: string | null;
      provider: string;
      createdAt: string;
      updatedAt: string;
    };
  } | null;
}

export interface StrapiCollectionResponse<T> {
  data: Array<T & StrapiBaseAttributes>;
  meta: {
    pagination: StrapiPagination;
  };
}

export interface StrapiEntityResponse<T> {
  data: T & StrapiBaseAttributes;
  meta: Record<string, unknown>;
}\n\n`;

    // Process each schema
    for (const [schemaName, schema] of Object.entries(schemas)) {
      // Skip internal Strapi types and Error responses
      if (schemaName.startsWith('Error')) continue;

      const interfaceName = schemaName.replace(/[^a-zA-Z0-9]/g, '');
      typeDefinitions += `export interface ${interfaceName} {\n`;

      if (schema.properties) {
        for (const [propName, prop] of Object.entries(schema.properties)) {
          const fieldType = getTypeScriptType(prop);
          const isRequired = schema.required?.includes(propName);
          typeDefinitions += `  ${propName}${isRequired ? '' : '?'}: ${fieldType};\n`;
        }
      }

      typeDefinitions += `}\n\n`;

      // Add collection and single response types
      typeDefinitions += `export type ${interfaceName}Collection = StrapiCollectionResponse<${interfaceName}>;\n`;
      typeDefinitions += `export type ${interfaceName}Entity = StrapiEntityResponse<${interfaceName}>;\n\n`;
    }

    // Create types directory if it doesn't exist
    const typesDir = path.join(process.cwd(), 'src/types');
    if (!fs.existsSync(typesDir)) {
      fs.mkdirSync(typesDir, { recursive: true });
    }

    // Write to file
    const outputPath = path.join(typesDir, 'strapi.ts');
    fs.writeFileSync(outputPath, typeDefinitions);

    console.log('âœ¨ Types generated successfully!');
  } catch (error) {
    console.error('Failed to generate types:', error);
    process.exit(1);
  }
}

function getTypeScriptType(field: any): string {
  if (field.type === 'array') {
    const itemType = getTypeScriptType(field.items);
    return `${itemType}[]`;
  }

  if (field.type === 'object' && field.properties) {
    let objectType = '{\n';
    for (const [propName, prop] of Object.entries(field.properties)) {
      const fieldType = getTypeScriptType(prop as any);
      const isRequired = field.required?.includes(propName);
      objectType += `    ${propName}${isRequired ? '' : '?'}: ${fieldType};\n`;
    }
    objectType += '  }';
    return objectType;
  }

  if (field.$ref) {
    // Handle references to other schemas
    const refType = field.$ref.split('/').pop();
    return refType.replace(/[^a-zA-Z0-9]/g, '');
  }

  switch (field.type) {
    case 'string':
      if (field.format === 'date' || field.format === 'date-time') {
        return 'string';
      }
      if (field.enum) {
        return field.enum.map((value: string) => `'${value}'`).join(' | ');
      }
      return 'string';
    case 'integer':
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'media':
      return 'StrapiMedia';
    default:
      if (field.oneOf) {
        return field.oneOf
          .map((type: any) => getTypeScriptType(type))
          .join(' | ');
      }
      return 'any';
  }
}

generateTypes();
